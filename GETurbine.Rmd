---
title: "GETurbine"
output: html_document
---

```{r}

filenameToRead<-"train.csv"
turbineData<-read.csv(filenameToRead)
str(turbineData)
plot(turbineData$X189,turbineData$X190)

```

Performing some explorations

```{r}
#Find the summary of the values

summary(turbineData$X189)

summary(turbineData$X190)


```
The summary clearly shows that the X190 and X189 have similar distribution


Now drawing the box plts and the histograms to see the disribution

```{r}
#boxplots
boxplot(turbineData$X190,turbineData$X189,names=c("X190","X189"))

#hist
hist(turbineData$X189)

hist(turbineData$X190)


#correlations
cor(turbineData$X189,turbineData$X190)

#plot the points with the linear regression line
plot(turbineData$X189,turbineData$X190)
abline(lm(turbineData$X190~turbineData$X189), col="red")


```

So the above graphs indicate that there is strong relation between the two set of data points.


```{r}
linreg1=lm(X190~X189,data=turbineData)
summary(linreg1)

fittingTrain=predict(linreg1)

#getting the residuals values using the summary function
residualsBySummary=summary(linreg1)$residuals

#calculating the residuals using the predictions and the actual value in teh training data
residualTrain=turbineData$X190-fittingTrain

#both should be same
diff=residualTrain-residualsBySummary


###now plotting the diagnostics plot

par(mfrow=c(2,2))
#diagnostics
plot(linreg1)




#getting the outliers
plot(fitted.values(linreg1),rstudent(linreg1))
abline(h=c(-3,3), col="red")
which(rstudent(linreg1)>3)



#values from the model
#residuals
linreg1$residuals

#get the fitted values
linreg1$fitted.values
#calculate the SSE
SSE=sum(linreg1$residuals^2)
RMSE=sqrt(SSE/nrow(turbineData))


```
some analysis

```{r}
#get the outliers
outlierTest(linreg1)

#get the high lebvergare points
influencePlot(linreg1)

##one thing could be to remove these points and then recalculate

#else if we do 
spreadLevelPlot(linreg1)

#correction
#suppose we remove the datapoints of 409, 635, 636

#turbineDataUpdated<-turbineData[-c(409,635,636),]
turbineDataUpdated<-turbineData
linreg2=lm(X190~X189+I(X189^2),data=turbineData)
summary(linreg2)

plot(linreg2)
SSE2=sum(linreg2$residuals^2)
RMSE2=sqrt(SSE2/nrow(turbineData))


#actually we can quickly see if tyhe power of the X189 will have any effect or not by calculating the 
#polynomial regression
polyLin<-lm(X190~poly(X189,3),data=turbineData)
summary(polyLin)
#we can see that on the ppower 1 is of any significane which means the linreg1

```
So not much of the significant changes in teh RMSE and R2 in case of the interaction model versus the simple linear model. So I would consider the first model to be better

Draw the standard error lines 
```{r}

preds<-predict(linreg1,se=TRUE)
#get the standard errors at any xo for the curve
se.bands=cbind(preds$fit+2*preds$se.fit,preds$fit-2*preds$se.fit)

#now plot the main region
plot(turbineData$X189,turbineData$X190,col="darkgrey")
#this is the main line
lines(turbineData$X189,preds$fit,lwd=2,col="blue")
#now draw the SE lines
matlines(turbineData$X189,se.bands,col="red",lty=2)


```

Run the model on the test data to see the predictions
```{r}
#read the test data
turbineTestData<-read.csv("test.csv")
summary(turbineTestData)
turbineSubTestData=turbineTestData[c(1:2),]
predictions=predict(linreg1,newdata=turbineTestData,interval="prediction")

#coeffs<-coef(linreg1)
#predictions<-coeffs[1]+coeffs[2]*turbineTestData$X189
head(predictions)
str(turbineTestData)
testErrorDiff=turbineTestData$X190-predictions...how to get the fit values

SSET=sum(testErrorDiff^2)
RMSET=sqrt(SSET/nrow(turbineTestData))
#mean to be calculated on the trainig set
baseSSE=sum((turbineTestData$X190-mean(turbineData$X190))^2)
R2=1-SSET/baseSSE

#see how the data is plotted
plot(turbineTestData$X190)
points(predictions,col="red")


```





All the variables

```{r}
model2=lm(turbineData$X190~.,data=turbineData)
summary(model2)
#data is highly correlated
cor(turbineData)

#beeter model as the R2 error is less than the earlier version
model3=lm(turbineData$X190~turbineData$X180+turbineData$X186+turbineData$X188+turbineData$X189+turbineData$X191+turbineData$X193+turbineData$X200)
summary(model3)

par(mfrow=c(2,2))

plot(model3)

SSE3=sum(model3$residuals^2)
RMSE3=sqrt(SSE3/nrow(turbineData))




#read the test data



####I DONT THINK THIS IS REQUIRED ######

which.max(hatvalues(model3)) 

residplot <- function(fit, nbreaks=10){
  z <- rstudent(fit)
  hist(z, breaks=nbreaks, freq=FALSE,xlab="Studentized Residual",main="Distribution of Errors")
  rug(jitter(z), col="brown")
  curve(dnorm(x, mean=mean(z), sd=sd(z)),add=TRUE, col="blue", lwd=2)
  lines(density(z)$x, density(z)$y,col="red", lwd=2, lty=2)
  #legend("topright",legend = c( "Normal Curve", "Kernel Density Curve"),lty=1:2, col=c("blue","red"), cex=.7)
}

residplot(model3)
library(car)
spreadLevelPlot(model3)

model4=lm(turbineData$X190^0.48~turbineData$X180+turbineData$X186+turbineData$X188+turbineData$X189+turbineData$X191+turbineData$X193+turbineData$X200)

summary(model4)

spreadLevelPlot(model4)

plot(model4)
#############

library(tree)
tree.train=tree(X190~.,data=turbineData)
plot(tree.train)
text(tree.train,pretty=0)





```
```{r}
library(leaps)
regfit.full=regsubsets(X190 ~.,turbineData)
summary(regfit.full)
```


Few approaches

1. Break the data into train and test
2. You want to reach to a model using a test set created from the known samples
3. Apply the minear regression (calculate the RMSE)
4. Apply the tree methods and then calculate the RMSE
5. Apply the non linear methods like spline etc to get the model

Once you get the model with a good RMSE and error you wil use this as the one for the test data provided



